package com.google.api.generator.gapic.composer.spanner;

import com.google.api.core.BetaApi;
import com.google.api.generator.engine.ast.AnnotationNode;
import com.google.api.generator.engine.ast.AssignmentExpr;
import com.google.api.generator.engine.ast.ClassDefinition;
import com.google.api.generator.engine.ast.Expr;
import com.google.api.generator.engine.ast.ExprStatement;
import com.google.api.generator.engine.ast.MethodDefinition;
import com.google.api.generator.engine.ast.NewObjectExpr;
import com.google.api.generator.engine.ast.RelationalOperationExpr;
import com.google.api.generator.engine.ast.ReturnExpr;
import com.google.api.generator.engine.ast.ScopeNode;
import com.google.api.generator.engine.ast.Statement;
import com.google.api.generator.engine.ast.ThisObjectValue;
import com.google.api.generator.engine.ast.TypeNode;
import com.google.api.generator.engine.ast.ValueExpr;
import com.google.api.generator.engine.ast.VaporReference;
import com.google.api.generator.engine.ast.Variable;
import com.google.api.generator.engine.ast.VariableExpr;
import com.google.api.generator.gapic.composer.common.ClassComposer;
import com.google.api.generator.gapic.composer.store.TypeStore;
import com.google.api.generator.gapic.model.Field;
import com.google.api.generator.gapic.model.GapicClass;
import com.google.api.generator.gapic.model.GapicClass.Kind;
import com.google.api.generator.gapic.model.GapicContext;
import com.google.api.generator.gapic.model.Message;
import com.google.api.generator.gapic.model.Service;
import com.google.api.generator.gapic.utils.JavaStyle;
import com.google.api.pathtemplate.PathTemplate;
import com.google.api.pathtemplate.ValidationException;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Sets;
import io.grpc.spanner.SpannerOptionsConfig;
import io.grpc.spanner.SpannerOptionsConfig.OptionMapperConfig;
import io.grpc.spanner.SpannerOptionsConfig.OptionMapperConfigList;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Generated;


/**
 * Generate an Option class which represents an Option parameter.
 */
public class SpannerOptionsStubClassComposer implements ClassComposer {
  private static final SpannerOptionsStubClassComposer INSTANCE =
      new SpannerOptionsStubClassComposer();
  private static final TypeStore FIXED_TYPESTORE = createStaticTypes();

  private static final VaporReference READ_AND_QUERY_OPTION =
      createVaporReference("com.google.cloud.spanner", "ReadAndQueryOption", "Options");
  private static final VaporReference TRANSACTION_OPTION =
      createVaporReference("com.google.cloud.spanner", "TransactionOption", "Options");
  private static final VaporReference INTERNAL_OPTION_REF =
      createVaporReference("com.google.cloud.spanner", "InternalOption");
  private static final VaporReference OPTIONS =
      createVaporReference("com.google.cloud.spanner", "Options");
  private static final Variable OPTIONS_VAR = createVarFromVaporRef(OPTIONS, "options");

  public static SpannerOptionsStubClassComposer instance() {
    return INSTANCE;
  }

  @Override
  public GapicClass generate(GapicContext context, Service service) {

    // Read the configuration for mapper
    SpannerOptionsConfig.OptionMapperConfigList optionMapperConfigList = parseSpannerOptionsConfig();

    // from the proto, parse the applicable fields which need to be autogenerated
    Map<Field, String> fields = getApplicableProtoFields(context, optionMapperConfigList);

    // Create inner class types for applicable fields
    // TODO generate and use the dynamic types
    TypeStore dynamicTypesForInnerClasses = getDynamicClasses(fields);

    List<Statement> memberVariables = new ArrayList<>();
    List<ClassDefinition> optionInnerClasses = new ArrayList<>();
    List<MethodDefinition> setterMethods = new ArrayList<>();
    List<MethodDefinition> hasMethods = new ArrayList<>();
    List<MethodDefinition> getterMethods = new ArrayList<>();
    List<MethodDefinition> allMethods = new LinkedList<>();

    for(Map.Entry<Field, String> field: fields.entrySet()) {

      // generate public method to set option value
      /**
       * public static Options.TransactionOption maxBatchingDelayMs(int maxBatchingDelayMs) {
       *     return new MaxBatchingDelayMsOption(maxBatchingDelayMs);
       *   }
       */
      String nameInLoweCamelCase = JavaStyle.toLowerCamelCase(field.getKey().name());
      String nameInUpperCamelCase = JavaStyle.toUpperCamelCase(field.getKey().name());
      Variable variable = Variable.builder().setName(nameInLoweCamelCase)
          .setType(getBoxedTypeWithFallBack(field.getKey().type())).build();
      VariableExpr variableExpr = VariableExpr.builder()
          .setScope(ScopeNode.LOCAL)
          .setVariable(variable)
          .build();
      // generate member variable
      // Integer maxBatchingDelayMs;
      VariableExpr memberVariableDeclExpr = VariableExpr.builder()
          .setIsDecl(true)
          .setScope(ScopeNode.PROTECTED)
          .setVariable(variable)
          .build();

      // generate method argument
      // Integer maxBatchingDelayMs;
      VariableExpr argumentVariableDeclExpr = VariableExpr.builder()
          .setIsDecl(true)
          .setScope(ScopeNode.LOCAL)
          .setVariable(variable)
          .build();

      VaporReference classRef =
          createVaporReference("com.google.cloud.spanner", nameInUpperCamelCase);
      NewObjectExpr returnExpr = NewObjectExpr.builder()
          .setType(TypeNode.withReference(classRef)) // TODO use a dynamic type
          .setArguments(variableExpr)
          .build();
      MethodDefinition setterMethod =
          MethodDefinition.builder()
              .setReturnType(TypeNode.withReference(classRef)) // TODO add the parent type
              .setName(JavaStyle.toLowerCamelCase(field.getKey().name()))
              .setArguments(argumentVariableDeclExpr)
              .setIsStatic(true)
              .setScope(ScopeNode.PUBLIC)
              .setReturnExpr(returnExpr)
              .build();
      setterMethods.add(setterMethod);

      VariableExpr memberVariableExpr = VariableExpr.withVariable(variable);

      memberVariables.add(ExprStatement.withExpr(memberVariableDeclExpr));

      // generate has method
      /**
       * boolean hasMaxBatchingDelayMs() {
       *     return maxBatchingDelayMs != null;
       *   }
       */
      Expr nullExpr = ValueExpr.createNullExpr();
      Expr isNullCheckExpr = RelationalOperationExpr.notEqualToWithExprs(memberVariableExpr, nullExpr);
      MethodDefinition hasMethod =
          MethodDefinition.builder()
              .setReturnType(TypeNode.BOOLEAN)
              .setName(String.format("has%s", nameInUpperCamelCase))
              .setScope(ScopeNode.PROTECTED)
              .setReturnExpr(isNullCheckExpr)
              .build();
      hasMethods.add(hasMethod);
      // generate getter method
      /**
       * int maxBatchingDelayMs() {
       *     return maxBatchingDelayMs;
       *   }
       */
      MethodDefinition getterMethod =
          MethodDefinition.builder()
              .setReturnType(getBoxedTypeWithFallBack(memberVariableExpr.type()))
              .setName(nameInLoweCamelCase)
              .setScope(ScopeNode.PROTECTED)
              .setReturnExpr(ReturnExpr.withExpr(memberVariableExpr))
              .build();
      getterMethods.add(getterMethod);

      optionInnerClasses.add(getInnerClassForOptionProtoField(field, classRef));
    }

    allMethods.addAll(setterMethods);
    allMethods.addAll(hasMethods);
    allMethods.addAll(getterMethods);

    // TODO handle the equals and hashcode methods
    // generate outer main class
    ClassDefinition outerClassDef =
        ClassDefinition.builder()
            .setPackageString("com.google.cloud.spanner")
            .setAnnotations(createClassAnnotations())
            .setScope(ScopeNode.LOCAL)
            .setNestedClasses(optionInnerClasses)
            .setStatements(memberVariables)
            .setName("AutoGeneratedOptions")
            .setMethods(allMethods)
            .build();

    return GapicClass.create(Kind.MAIN, outerClassDef);
  }

  private TypeStore getDynamicClasses(Map<Field, String> fields) {
    TypeStore dynamicTypes = new TypeStore();
    for (Map.Entry<Field, String> field : fields.entrySet()) {
      String className = JavaStyle.toUpperCamelCase(field.getKey().name());
      dynamicTypes.put("com.google.cloud.spanner", className);
    }
    return dynamicTypes;
  }

  private static TypeNode getBoxedTypeWithFallBack(TypeNode type) {
    return type.isPrimitiveType() ?
        TypeNode.BOXED_TYPE_MAP.get(type) : type;
  }

  private Map<Field, String> getApplicableProtoFields(GapicContext context, OptionMapperConfigList optionMapperConfigList) {

    Map<String, String> config = optionMapperConfigList.getValuesList().stream()
        .collect(Collectors.toMap(OptionMapperConfig::getFieldName, OptionMapperConfig::getMappingGroup));
    Map<String, Message> messages = context.messages();
    Map<String, Field> allFields = new HashMap<>();
    Set<String> intersectedFields = new HashSet<>();
    for(Map.Entry<String, Message> entry: messages.entrySet()) {
      // TODO : test this bit of code
      Message message = entry.getValue();
      Map<String, Field> fields = message.fieldMap();
      allFields.putAll(fields);
      intersectedFields.addAll(Sets.intersection(config.keySet(), fields.keySet()));
    }
    return intersectedFields.stream().collect(
        Collectors.toMap(fieldName-> allFields.getOrDefault(fieldName, null),
            fieldName -> config.getOrDefault(fieldName, null)));
  }

  /**
   *
   * static final class MaxBatchingDelayMsOption extends InternalOption implements Options.TransactionOption {
   *   private final Integer maxBatchingDelayMs;
   *
   *   MaxBatchingDelayMsOption(Integer maxBatchingDelayMs) {
   *     this.maxBatchingDelayMs = maxBatchingDelayMs;
   *   }
   *
   *   @Override
   *   void appendToOptions(Options options) {
   *     options.maxBatchingDelayMs = maxBatchingDelayMs;
   *   }
   * }
   *
   * @return
   */
  private static ClassDefinition getInnerClassForOptionProtoField(
      final Map.Entry<Field, String> field, final VaporReference classRef) {
    String nameInLoweCamelCase = JavaStyle.toLowerCamelCase(field.getKey().name());
    String nameInUpperCamelCase = JavaStyle.toUpperCamelCase(field.getKey().name());

    Variable variable = Variable.builder().setName(nameInLoweCamelCase)
        .setType(getBoxedTypeWithFallBack(field.getKey().type())).build();
    VariableExpr variableExpr = VariableExpr.builder()
        .setIsDecl(true)
        .setScope(ScopeNode.PRIVATE)
        .setIsFinal(true)
        .setVariable(variable)
        .build();

    // create the constructor method
    VariableExpr thisVariableExpr = createVarExprFromRefThisExpr(variable, classRef);
    AssignmentExpr thisAssignExpr = createAssignmentExpr(thisVariableExpr,
        VariableExpr.withVariable(variable));
    // TODO : explore what's a clean strategy to pass datatypes instead of getBoxedTypeWithFallBack
    MethodDefinition constructor =
        MethodDefinition.constructorBuilder()
            .setArguments(
                Arrays.asList(VariableExpr.builder()
                    .setIsDecl(true)
                    .setVariable(Variable.builder().setName(nameInLoweCamelCase)
                        .setType(getBoxedTypeWithFallBack(field.getKey().type())).build())
                    .build()))
            .setScope(ScopeNode.PUBLIC)
            .setBody(
                Arrays.asList(ExprStatement.withExpr(thisAssignExpr)))
            .setReturnType(TypeNode.withReference(classRef))
            .build();

    // create append method
    // options.maxBatchingDelayMs = maxBatchingDelayMs;
    VariableExpr optionNameFromOptionsClass = fieldFromParentObjectExpr(OPTIONS_VAR, variable);
    AssignmentExpr optionsAssignExpr = createAssignmentExpr(optionNameFromOptionsClass,
        VariableExpr.withVariable(variable));

    MethodDefinition appendToOptions =
        MethodDefinition.builder()
            .setAnnotations(Arrays.asList(AnnotationNode.OVERRIDE))
            .setArguments(VariableExpr.builder()
                .setIsDecl(true)
                .setVariable(OPTIONS_VAR)
                .build())
            .setReturnType(TypeNode.VOID)
            .setName("appendToOptions")
            .setScope(ScopeNode.PUBLIC)
            .setBody(
                Arrays.asList(ExprStatement.withExpr(optionsAssignExpr)))
            .build();

    ClassDefinition classDefinition =
        ClassDefinition.builder()
            .setImplementsTypes(Arrays.asList(getOptionsGroupTypeNode(field.getValue())))
            .setExtendsType(TypeNode.withReference(INTERNAL_OPTION_REF))
            .setScope(ScopeNode.PROTECTED)
            .setIsStatic(true)
            .setIsFinal(true)
            .setName(nameInUpperCamelCase)
            .setIsNested(true)
            .setStatements(Arrays.asList(ExprStatement.withExpr(variableExpr)))
            .setMethods(Arrays.asList(constructor, appendToOptions))
            .build();
    return classDefinition;
  }

  private static TypeNode getOptionsGroupTypeNode(final String value) {
    // TODO add other mapping groups to the below switch case
    switch (value) {
      case "TransactionOption" :
        return TypeNode.withReference(TRANSACTION_OPTION);
      case "ReadAndQueryOption" :
        return TypeNode.withReference(READ_AND_QUERY_OPTION);
      default:
        throw new RuntimeException(String.format("Invalid value => %s provided.", value));
    }
  }

  private static List<AnnotationNode> createClassAnnotations() {
    return Arrays.asList(
        AnnotationNode.builder()
            .setType(FIXED_TYPESTORE.get("Generated"))
            .setDescription("by gapic-generator-java")
            .build());
  }

  private static TypeStore createStaticTypes() {
    List<Class<?>> concreteClazzes =
        Arrays.asList(
            ArrayList.class,
            BetaApi.class,
            Generated.class,
            ImmutableMap.class,
            List.class,
            Map.class,
            Objects.class,
            PathTemplate.class,
            Preconditions.class,
            com.google.api.resourcenames.ResourceName.class,
            ValidationException.class);
    return new TypeStore(concreteClazzes);
  }

  private static VariableExpr fieldFromParentObjectExpr(Variable variable, Variable parentField) {
    return createVarExprFromRefVarExpr(parentField, VariableExpr.withVariable(variable));
  }

  private static VariableExpr createVarExprFromRefVarExpr(Variable var, Expr varRef) {
    return VariableExpr.builder().setVariable(var).setExprReferenceExpr(varRef).build();
  }
  private static Variable createVarFromVaporRef(VaporReference ref, String name) {
    return Variable.builder().setName(name).setType(TypeNode.withReference(ref)).build();
  }
  private static VaporReference createVaporReference(String pkgName,
      String name, String... enclosingClassNames) {
    return VaporReference.builder().setPakkage(pkgName)
        .setName(name)
        .setEnclosingClassNames(enclosingClassNames).build();
  }

  private static VariableExpr createVarExprFromRefThisExpr(Variable var, VaporReference ref) {
    return VariableExpr.builder()
        .setVariable(var)
        .setExprReferenceExpr(
            ValueExpr.withValue(ThisObjectValue.withType(TypeNode.withReference(ref))))
        .build();
  }

  private static AssignmentExpr createAssignmentExpr(VariableExpr variableExpr, Expr valueExpr) {
    return AssignmentExpr.builder().setVariableExpr(variableExpr).setValueExpr(valueExpr).build();
  }
  private SpannerOptionsConfig.OptionMapperConfigList parseSpannerOptionsConfig() {
    String yamlFilename = "com/google/api/generator/gapic/composer/spanner/config/spanner_options_mapper.yaml";
    Path path = Paths.get("src/main/java", yamlFilename);
    Optional<SpannerOptionsConfig.OptionMapperConfigList> optionsMapperSettings =
        SpannerOptionsConfigParser.parse(path.toString());
    return optionsMapperSettings.get();
  }
}

